import subprocess
import json
import pickle
from pathlib import Path
from typing import Dict, Optional
from config.settings import settings
from utils.validators import sanitize_filename
from utils.exceptions import VideoDownloadError
import structlog

logger = structlog.get_logger(__name__)


class VideoDownloadService:
    """Service for downloading videos using yt-dlp"""

    def __init__(self, download_base_path: Optional[Path] = None):
        """
        Initialize video download service

        Args:
            download_base_path: Base directory for downloads (defaults to settings)
        """
        self.base_path = download_base_path or settings.DOWNLOAD_BASE_PATH
        self.base_path = Path(self.base_path)
        self.cookies_file = None

    def _prepare_instagram_cookies(self) -> Optional[Path]:
        """
        Prepare Instagram cookies file from instaloader session

        Returns:
            Path to cookies file if successful, None otherwise
        """
        try:
            # Path to instaloader session file
            session_file = Path(__file__).parent.parent / "data" / ".instaloader_session"

            if not session_file.exists():
                logger.warning("Instaloader session file not found", path=str(session_file))
                return None

            # Load instaloader session (dict of cookie_name: cookie_value)
            with open(session_file, 'rb') as f:
                session_data = pickle.load(f)

            if not isinstance(session_data, dict):
                logger.warning("Instaloader session format unexpected", type=type(session_data))
                return None

            # Create cookies file for yt-dlp (Netscape format)
            cookies_file = self.base_path / "instagram_cookies.txt"

            with open(cookies_file, 'w') as f:
                # Netscape HTTP Cookie File header
                f.write("# Netscape HTTP Cookie File\n")
                f.write("# This file was generated by VideoDownloadService\n\n")

                # Convert session dict to Netscape cookie format
                # Instaloader stores cookies as {name: value}
                for name, value in session_data.items():
                    # Netscape format: domain, flag, path, secure, expiration, name, value
                    domain = ".instagram.com"
                    flag = "TRUE"
                    path = "/"
                    secure = "TRUE"
                    expiration = "0"  # Session cookie

                    f.write(f"{domain}\t{flag}\t{path}\t{secure}\t{expiration}\t{name}\t{value}\n")

            logger.info("Instagram cookies file prepared", path=str(cookies_file), cookie_count=len(session_data))
            return cookies_file

        except FileNotFoundError:
            logger.warning("Instaloader session file not found")
            return None
        except Exception as e:
            logger.error(f"Failed to prepare Instagram cookies: {e}", exc_info=True)
            return None

    def download(self, post_url: str, platform: str, post_id: str) -> Dict:
        """
        Download video using yt-dlp

        Args:
            post_url: URL of the post/video
            platform: Platform name (instagram, tiktok, youtube)
            post_id: Unique post identifier

        Returns:
            Dictionary with keys: status, file_path, error
            - status: "success" or "error"
            - file_path: Path to downloaded file (if successful)
            - error: Error message (if failed)
        """
        # Create platform-specific directory
        output_dir = self.base_path / platform
        output_dir.mkdir(parents=True, exist_ok=True)

        # Sanitize post_id for filename
        safe_post_id = sanitize_filename(post_id)
        output_template = str(output_dir / f"{safe_post_id}.%(ext)s")

        # Build yt-dlp command
        cmd = [
            "yt-dlp",
            "--output", output_template,
            "--no-playlist",
            "--write-info-json",
            "--max-filesize", settings.YTDLP_MAX_FILESIZE,
        ]

        # Platform-specific format selection
        if platform == "instagram":
            # Instagram: Try best quality, fallback to any available format
            cmd.extend(["--format", "best/b/bv*+ba/bv+ba"])

            # Add Instagram authentication using cookies
            cookies_file = self._prepare_instagram_cookies()
            if cookies_file:
                cmd.extend(["--cookies", str(cookies_file)])
                logger.debug("Using Instagram cookies for download", cookies_file=str(cookies_file))
            else:
                logger.warning("No Instagram cookies available, trying without authentication")
        else:
            # Other platforms: Use configured format
            cmd.extend(["--format", settings.YTDLP_FORMAT])

        cmd.append(post_url)

        logger.info(
            "Starting video download",
            post_url=post_url,
            platform=platform,
            post_id=post_id
        )

        try:
            # Run yt-dlp command
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=300  # 5 minute timeout
            )

            if result.returncode == 0:
                # Find the downloaded file
                video_path = self._find_downloaded_file(output_dir, safe_post_id)

                if video_path:
                    logger.info(
                        "Video download successful",
                        post_url=post_url,
                        file_path=str(video_path)
                    )
                    return {
                        "status": "success",
                        "file_path": str(video_path),
                        "error": None
                    }
                else:
                    error_msg = "Download completed but file not found"
                    logger.error(error_msg, post_url=post_url)
                    return {
                        "status": "error",
                        "file_path": None,
                        "error": error_msg
                    }
            else:
                error_msg = result.stderr or "Unknown download error"
                logger.error(
                    "Video download failed",
                    post_url=post_url,
                    error=error_msg
                )
                return {
                    "status": "error",
                    "file_path": None,
                    "error": error_msg
                }

        except subprocess.TimeoutExpired:
            error_msg = "Download timeout (5 minutes)"
            logger.error("Video download timeout", post_url=post_url)
            return {
                "status": "error",
                "file_path": None,
                "error": error_msg
            }
        except FileNotFoundError:
            error_msg = "yt-dlp not found. Please install: pip install yt-dlp"
            logger.error(error_msg)
            return {
                "status": "error",
                "file_path": None,
                "error": error_msg
            }
        except Exception as e:
            error_msg = f"Unexpected error: {str(e)}"
            logger.error(
                "Video download unexpected error",
                post_url=post_url,
                error=str(e),
                exc_info=True
            )
            return {
                "status": "error",
                "file_path": None,
                "error": error_msg
            }

    def _find_downloaded_file(self, output_dir: Path, post_id: str) -> Optional[Path]:
        """
        Find the downloaded video file

        Args:
            output_dir: Directory where file should be
            post_id: Post identifier used in filename

        Returns:
            Path to video file if found, None otherwise
        """
        # Common video extensions
        video_extensions = [".mp4", ".mkv", ".webm", ".mov", ".avi", ".flv"]

        for ext in video_extensions:
            video_path = output_dir / f"{post_id}{ext}"
            if video_path.exists():
                return video_path

        # If not found with exact post_id, search for files starting with post_id
        for file_path in output_dir.glob(f"{post_id}*"):
            if file_path.suffix in video_extensions:
                return file_path

        return None

    def get_video_info(self, post_url: str, platform: str = None) -> Optional[Dict]:
        """
        Get video information without downloading

        Args:
            post_url: URL of the post/video
            platform: Platform name (for authentication)

        Returns:
            Dictionary with video metadata or None if failed
        """
        cmd = [
            "yt-dlp",
            "--dump-json",
            "--no-playlist",
        ]

        # Add Instagram authentication using cookies
        if platform == "instagram":
            cookies_file = self._prepare_instagram_cookies()
            if cookies_file:
                cmd.extend(["--cookies", str(cookies_file)])

        cmd.append(post_url)

        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode == 0:
                return json.loads(result.stdout)
            else:
                logger.warning(
                    "Failed to get video info",
                    post_url=post_url,
                    error=result.stderr
                )
                return None

        except Exception as e:
            logger.error(
                "Error getting video info",
                post_url=post_url,
                error=str(e)
            )
            return None

    def verify_file_exists(self, file_path: str) -> bool:
        """
        Verify that a downloaded file exists and is readable

        Args:
            file_path: Path to file

        Returns:
            True if file exists and is readable, False otherwise
        """
        try:
            path = Path(file_path)
            return path.exists() and path.is_file() and path.stat().st_size > 0
        except Exception:
            return False
